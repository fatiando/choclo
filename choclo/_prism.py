"""
Forward modelling functions for prisms
"""
import numpy as np
from numba import jit, prange


def prism_gravity(coordinates, prisms, density, kernel, out, progress_proxy=None):
    """
    Compute gravitational field of prisms on computations points

    Parameters
    ----------
    coordinates : tuple
        Tuple containing ``easting``, ``northing`` and ``upward`` of the
        computation points as arrays, all defined on a Cartesian coordinate
        system and in meters.
    prisms : 2d-array
        Two dimensional array containing the coordinates of the prism(s) in the
        following order: west, east, south, north, bottom, top in a Cartesian
        coordinate system.
        All coordinates should be in meters.
    density : 1d-array
        Array containing the density of each prism in kg/m^3. Must have the
        same size as the number of prisms.
    kernel : func
        Kernel function that will be used to compute the desired field.
    out : 1d-array
        Array where the resulting field values will be stored.
        Must have the same size as the arrays contained on ``coordinates``.
    """
    # Check if we need to update the progressbar on each iteration
    update_progressbar = progress_proxy is not None
    # Iterate over computation points and prisms
    for l in prange(coordinates[0].size):
        for m in range(prisms.shape[0]):
            # Iterate over the prism boundaries to compute the result of the
            # integration (see Nagy et al., 2000)
            for i in range(2):
                for j in range(2):
                    for k in range(2):
                        shift_east = prisms[m, 1 - i]
                        shift_north = prisms[m, 3 - j]
                        shift_upward = prisms[m, 5 - k]
                        # If i, j or k is 1, the shift_* will refer to the
                        # lower boundary, meaning the corresponding term should
                        # have a minus sign
                        out[l] += (
                            density[m]
                            * (-1) ** (i + j + k)
                            * kernel(
                                shift_east - coordinates[0][l],
                                shift_north - coordinates[1][l],
                                shift_upward - coordinates[2][l],
                            )
                        )
        # Update progress bar if called
        if update_progressbar:
            progress_proxy.update(1)


@jit(nopython=True)
def kernel_prism_potential(easting, northing, upward):
    r"""
    Kernel for the potential field due to a rectangular prism

    Evaluates the numerical integration kernel for the potential field
    generated by a prism [Nagy2000] on a single vertex of the prism. The
    coordinates that must be passed are reduced coordinates: the coordinates of
    the vertex from a Cartesian coordinate system whose origin is located in
    the observation point.

    This function makes use of a safe natural logarithmic function and a safe
    arctangent function [Fukushima2020]_ that guarantee a good accuracy on
    every observation point.

    Parameters
    ----------
    easting : float
        Reduced easting coordinate of the vertex of the prism
    northing : float
        Reduced northing coordinate of the vertex of the prism
    upward : float
        Reduced upward coordinate of the vertex of the prism

    Returns
    -------
    kernel : float
        Value of the numerical kernel function for the potential field due to
        a rectangular prism evaluated on a single vertex.

    Notes
    -----
    Computes the following numerical kernel on the passed *reduced
    coordinates*:

    .. math::

            k_V(x, y, z) &=
                x y \, \text{ln2} (z + r)
                + y z \, \text{ln2} (x + r)
                + z x \, \text{ln2} (y + r) \\
                & - \frac{x^2}{2} \text{arctan2} \left( \frac{yz}{xr} \right)
                - \frac{y^2}{2} \text{arctan2} \left( \frac{zx}{yr} \right)
                - \frac{z^2}{2} \text{arctan2} \left( \frac{xy}{zr} \right)

    where

    .. math::

        \text{ln2}(x) =
        \begin{cases}
            0 & |x| < 10^{-10} \\
            \ln (x)
        \end{cases}

    and

    .. math::

        \text{arctan2} \left( \frac{y}{x} \right) =
        \begin{cases}
            \text{arctan}\left( \frac{y}{x} \right) & x \ne 0 \\
            \frac{\pi}{2} & x = 0 \quad \text{and} \quad y > 0 \\
            -\frac{\pi}{2} & x = 0 \quad \text{and} \quad y < 0 \\
            0 & x = 0 \quad \text{and} \quad y = 0 \\
        \end{cases}

    References
    ----------
    - [Nagy2000]_
    - [Nagy2002]_
    - [Fukushima2020]_
    """
    radius = np.sqrt(easting**2 + northing**2 + upward**2)
    kernel = (
        easting * northing * _safe_log(upward + radius)
        + northing * upward * _safe_log(easting + radius)
        + easting * upward * _safe_log(northing + radius)
        - 0.5 * easting**2 * _safe_atan2(upward * northing, easting * radius)
        - 0.5 * northing**2 * _safe_atan2(upward * easting, northing * radius)
        - 0.5 * upward**2 * _safe_atan2(easting * northing, upward * radius)
    )
    return kernel


@jit(nopython=True)
def kernel_prism_g_upward(easting, northing, upward):
    r"""
    Kernel for upward component of the gradient due to a rectangular prism

    Evaluates the numerical integration kernel for the upward component of the
    gradient of the potential field generated by a prism [Nagy2000] on a single
    vertex of the prism. The coordinates that must be passed are reduced
    coordinates: the coordinates of the vertex from a Cartesian coordinate
    system whose origin is located in the observation point.

    This function makes use of a safe natural logarithmic function and a safe
    arctangent function [Fukushima2020]_ that guarantee a good accuracy on
    every observation point.

    Parameters
    ----------
    easting : float
        Reduced easting coordinate of the vertex of the prism
    northing : float
        Reduced northing coordinate of the vertex of the prism
    upward : float
        Reduced upward coordinate of the vertex of the prism

    Returns
    -------
    kernel : float
        Value of the numerical kernel function for the upward component of the
        gradient of the potential field due to a rectangular prism evaluated on
        a single vertex.

    Notes
    -----
    Computes the following numerical kernel on the passed *reduced
    coordinates*:

    .. math::

        k_{g_z}(x, y, z) = - \left[
            x \, \text{ln2} (y + r)
            + y \, \text{ln2} (x + r)
            - z \, \text{arctan2} \left( \frac{xy}{zr} \right)
            \right]

    .. important::

        In the previous equation a minus sign has been added to the one
        obtained by [Nagy2000]_ in order to compute the numerical kernel for
        the **upward** component instead for the downward one.

    where

    .. math::

        \text{ln2}(x) =
        \begin{cases}
            0 & |x| < 10^{-10} \\
            \ln (x)
        \end{cases}

    and

    .. math::

        \text{arctan2} \left( \frac{y}{x} \right) =
        \begin{cases}
            \text{arctan}\left( \frac{y}{x} \right) & x \ne 0 \\
            \frac{\pi}{2} & x = 0 \quad \text{and} \quad y > 0 \\
            -\frac{\pi}{2} & x = 0 \quad \text{and} \quad y < 0 \\
            0 & x = 0 \quad \text{and} \quad y = 0 \\
        \end{cases}

    References
    ----------
    - [Nagy2000]_
    - [Nagy2002]_
    - [Fukushima2020]_
    """
    radius = np.sqrt(easting**2 + northing**2 + upward**2)
    # The minus sign is to return the kernel for the upward component instead
    # of the downward one.
    kernel = -(
        easting * _safe_log(northing + radius)
        + northing * _safe_log(easting + radius)
        - upward * _safe_atan2(easting * northing, upward * radius)
    )
    return kernel


@jit(nopython=True)
def _safe_atan2(y, x):
    r"""
    Principal value of the arctangent expressed as a two variable function

    This modification has to be made to the arctangent function so the
    gravitational field of the prism satisfies the Poisson's equation.
    Therefore, it guarantees that the fields satisfies the symmetry properties
    of the prism. This modified function has been defined according to
    [Fukushima2020]_.

    Notes
    -----

    .. math::

        \text{arctan2} \left( \frac{y}{x} \right) =
        \begin{cases}
            \text{arctan}\left( \frac{y}{x} \right) & x \ne 0 \\
            \frac{\pi}{2} & x = 0 \quad \text{and} \quad y > 0 \\
            -\frac{\pi}{2} & x = 0 \quad \text{and} \quad y < 0 \\
            0 & x = 0 \quad \text{and} \quad y = 0 \\
        \end{cases}

    References
    ----------
    - [Fukushima2020]_
    """
    if x != 0:
        result = np.arctan(y / x)
    else:
        if y > 0:
            result = np.pi / 2
        elif y < 0:
            result = -np.pi / 2
        else:
            result = 0
    return result


@jit(nopython=True)
def _safe_log(x):
    r"""
    Modified log to return zero for values of x close to zero

    This modified version of the log function makes the computations to agree
    with the limits of the integral (see [Nagy2000]_).

    Notes
    -----

    .. math::

        \text{ln2}(x) =
        \begin{cases}
            0 & |x| < 10^{-10} \\
            \ln (x)
        \end{cases}

    References
    ----------
    - [Nagy2000]_
    """
    if np.abs(x) < 1e-10:
        result = 0
    else:
        result = np.log(x)
    return result
